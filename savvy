#!/usr/bin/python

import sys
import re
import random
import string
import argparse
import os
import ansible.parsing.vault as vault
from ansible.parsing.vault import VaultAES256, VaultSecret

allcommands="decrypt, encrypt, view, split, join"
parser = argparse.ArgumentParser(description='Single Ansible Vault Var encrYpter/decrYpter')
#parser.add_argument('-m', '--multi', action='store_true', help='use multiline format')
parser.add_argument('-q', '--quiet', action='store_true', help='show no informational output')
parser.add_argument('-d', '--debug', action='store_true', help='print debug info')
parser.add_argument('-o', '--output', help='output file')
parser.add_argument('-j', '--joinfile', help='join file contains passwords that can be merged in main file')
parser.add_argument('command', help=allcommands)
parser.add_argument('filename', nargs='?', default='group_vars/all/vars.yml', help='file to work on')
args = parser.parse_args()
singline_indent=40

if 'VAULT_PASS' in os.environ:
    vault_pass=VaultSecret(os.environ['VAULT_PASS'])
else:
    raise SystemExit("please set (read -s) and export VAULT_PASS")

def input_open():
    with open(args.filename) as inp:
        inputlines = inp.readlines()
    return inputlines

outputfile=None
outputlines=[]
def output_open(defaultfile):
    global outputfile
    if args.output:
        file=args.output
    else:
        file=defaultfile
    if file==None or file=="-":
        outputfile=None
    else:
        outputfile=file
def output_close():
    if outputfile==None or outputfile=="-":
        return
    else:
        verbose("Writing to file: "+outputfile)
        f = open(outputfile, "w")
        for l in outputlines:
            f.write(l)
def output(str, newline=True):
    if outputfile==None:
        print(str)
    else:
        if newline:
            outputlines.append(str+"\n")
        else:
            outputlines.append(str)

joinfile=None
joinlines=None
def open_joinfile(defaultfile):
    global joinlines
    global joinfile
    if (args.joinfile):
        joinfile=args.joinfile
    else:
        joinfile=defaultfile
    if joinfile:
        joinlines=['---', '']
def close_joinfile():
    if joinlines:
        verbose("Writing to joinfile: "+joinfile)
        f = open(joinfile, "w")
        for l in joinlines:
            f.write(l+"\n")


def verbose(str):
    if args.quiet:
        return
    print(str)
def debug(str):
    if args.quiet:
        return
    if args.debug:
        print(str)



def randomstring(length=16):
    letters = string.ascii_lowercase + string.ascii_uppercase + string.digits
    return ''.join(random.SystemRandom().choice(letters) for i in range(length))

def encrypt(raw):
    return VaultAES256.encrypt(raw,vault_pass)
def decrypt(raw):
    return VaultAES256.decrypt(raw,vault_pass)

def output_encrypted_var(name, value,multiline):
    encrypted_value=vault.format_vaulttext_envelope(encrypt(value),'AES256')
    if not multiline:
        indent=' '* (singline_indent-len(name))
        output(name+": !vault " +indent+encrypted_value.replace("\n", "\\n"))
    else:
        output(name+": !vault |")
        indent=' '*10
        for line in encrypted_value.splitlines():
            output('%s%s' % (indent, line))


def encrypt_file(lines):
    cnt=0
    skipcnt=0
    for line in lines:
        #if args.debug:
        #    debug("Line {}: {}".format(cnt+1, line.rstrip()))
        if skipcnt>0:
            skipcnt-=1
            cnt+=1
            continue
        parts= re.split(":[ \t]*@savvy[ \t]*",line)
        if len(parts)==1:
            #debug("keeping: "+line)
            output(line.rstrip())
        elif parts[1].startswith('generate'):
            multiline=True #args.force_multine or len(options)>0
            value=randomstring()
            verbose("generating: "+parts[0])
            output_encrypted_var(parts[0], value, multiline)
        else:
            key=parts[0]
            remainder=re.sub("^[^:]*:[ \t]*@savvy[ \t]*","",line,1)
            value=re.sub("^[^:]*:[ \t]","",remainder,1).strip()
            #debug( "****"+remainder+"..."+value)
            if value.startswith('"') and value.endswith('"'):
                value=value[1:-1]
                # TODO: embedded quotes might be escaped
            (origkey,origvalue,origmultiline,count)=decrypt_line(lines,cnt+1)
            multiline=True #args.force_multine or len(options)>0
            debug("Found key %s with next key %s" % (key, origkey))
            if key!=origkey:
                verbose("new key: "+key)
                output_encrypted_var(key, value, multiline)
            elif value!=origvalue:
                verbose("changed key: "+key)
                output_encrypted_var(key, value, multiline)
                skipcnt=count
            elif multiline!=origmultiline:
                verbose("changed format: "+key)
                output_encrypted_var(key, value, multiline)
                skipcnt=count
            else:
                verbose("unmodified key: "+key)

        cnt+=1

def decrypt_file(lines):
    cnt=0
    for line in lines:
        #if args.debug:
        #    debug("Line {}: {}".format(cnt+1, line.rstrip()))
        parts= re.split(":[ \t]*",line)
        if len(parts)>1:
            (key, value, multiline, count) = decrypt_line(lines, cnt)
            if key:
                if multiline:
                    verbose("multiline: "+key)
                    str = key+": @savvy multiline: "+value
                else:
                    verbose("singleline: "+key)
                    str = key+": @savvy: "+value
                if joinlines:
                    joinlines.append(str)
                else:
                    output(str)

        output(line.rstrip())
        cnt+=1

def show_file(lines):
    cnt=0
    for line in lines:
        parts= re.split(":[ \t]*",line)
        if len(parts)>1:
            (key, value, multiline, skipcount) = decrypt_line(lines, cnt)
            if key:
                output(key+": "+value)
        cnt+=1


def decrypt_line(lines, index):
    parts= re.split(":[ \t]*",lines[index])
    if len(parts)==1:
        return (None,None,False,0)
    str=""
    multiline=False
    skipcount=0
    if re.search('!vault[ \t]*\|',parts[1]):
        i=index+2
        skipcount=2
        while i<len(lines) and re.search('^[ \t]*[0-9a]*[ \t]*$',lines[i]):
            str+=lines[i].strip()
            i+=1
            skipcount+=1
        multiline=True
    elif parts[1].startswith('!vault'):
        match=re.search('!vault[ \t]*\$ANSIBLE_VAULT;1.1;AES256', parts[1])
        if match:
            str=parts[1][match.end():].replace('\\n','').strip()
            skipcount=1
    if len(str)>0:
        return (parts[0].strip(), decrypt(str).strip(), multiline, skipcount)
    return (None,None,False,0)

def command(name):
    if len(name)<len(args.command):
        return False
    return name.startswith(args.command)

if command('encrypt'):
    lines=input_open()
    output_open(args.filename)
    encrypt_file(lines)
    output_close()
elif command('decrypt'):
    lines=input_open()
    output_open(args.filename)
    open_joinfile(None)
    decrypt_file(lines)
    close_joinfile()
    if not joinfile:
        output_close()
elif command('view'):
    lines=input_open()
    output_open("-")
    show_file(lines)
elif command('join'):
    lines=input_open()
    output_open(args.filename)
    encrypt_file(lines)
    output_close()
elif command('split'):
    lines=input_open()
    open_joinfile('savvy.joinfile')
    output_open(args.filename)
    decrypt_file(lines)
    close_joinfile()
else:
    sys.stderr.write("Unknown command '%s', must be any of %s\n" % (args.command, allcommands))
