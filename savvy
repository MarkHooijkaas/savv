#!/usr/bin/python

import sys
import re
import random
import string
import argparse
import os
import ansible.parsing.vault as vault
from ansible.parsing.vault import VaultAES256, VaultSecret
from getpass import getpass
from argparse import RawTextHelpFormatter

epilogtext='''
commands:
  - savvy decrypt: decrypt all !vault variables in a file with special @savvy marker
  - savvy split :  decrypt all !vault variables in a separate mergefile
  - savvy encrypt: encrypt all @savvy annotated variables in a file
  - savvy merge:   encrypt all variables from a mergefile into the main file (not implemented yet)
  - savvy view:    show all encrypted variables in a file
  - savvy edit:    decrypt, edit, and re-encrypt (not implemented yet)

All commands can be abbreviated with the first letter or letters, for example to decrypt:
  - savvy d
  - savvy de
  - savvy dec
  - savvy decr

If two commands start with the same letter(s) the first command will be used
  - savvy e     will encrypt
  - savvy ed    will edit
'''

allcommands="decrypt, encrypt, view, split, merge"
parser = argparse.ArgumentParser(description='Single Ansible Vault Var encrYpter/decrYpter', epilog=epilogtext,  formatter_class=RawTextHelpFormatter)
#parser.add_argument('-m', '--multi', action='store_true', help='use multiline format')
parser.add_argument('-q', '--quiet', action='store_true', help='show no informational output')
parser.add_argument('-d', '--debug', action='store_true', help='print debug info')
parser.add_argument('-a', '--ask-password',  action='store_true',help='ask for a password (even if VAULT_PASS is set)')
parser.add_argument('-o', '--output', help='output file')
parser.add_argument('-j', '--mergefile', help='merge file with passwords to be split from or merged into main file')
parser.add_argument('command', help=allcommands)
parser.add_argument('filename', nargs='?', default='group_vars/all/vars.yml', help='file to work on')
args = parser.parse_args()
singline_indent=40

if 'VAULT_PASS' in os.environ and not args.ask_password:
    vault_pass=VaultSecret(os.environ['VAULT_PASS'])
else:
    vault_pass = VaultSecret(getpass("Vault Password:"))

def input_open():
    with open(args.filename) as inp:
        inputlines = inp.readlines()
    return inputlines

outputfile=None
outputlines=[]
def output_open(defaultfile):
    global outputfile
    if args.output:
        file=args.output
    else:
        file=defaultfile
    if file==None or file=="-":
        outputfile=None
    else:
        outputfile=file
def output_close():
    if outputfile==None or outputfile=="-":
        return
    else:
        verbose("Writing to file: "+outputfile)
        f = open(outputfile, "w")
        for l in outputlines:
            f.write(l)
def output(str, newline=True):
    if outputfile==None:
        print(str)
    else:
        if newline:
            outputlines.append(str+"\n")
        else:
            outputlines.append(str)

mergefile=None
mergelines=None
def open_mergefile(defaultfile):
    global mergelines
    global mergefile
    if (args.mergefile):
        mergefile=args.mergefile
    else:
        mergefile=defaultfile
    if mergefile:
        mergelines=['---', '']
def close_mergefile():
    if mergelines:
        verbose("Writing to mergefile: "+mergefile)
        f = open(mergefile, "w")
        for l in mergelines:
            f.write(l+"\n")


def verbose(str):
    if args.quiet:
        return
    print(str)
def debug(str):
    if args.quiet:
        return
    if args.debug:
        print(str)



def randomstring(length=16):
    letters = string.ascii_lowercase + string.ascii_uppercase + string.digits
    return ''.merge(random.SystemRandom().choice(letters) for i in range(length))

def encrypt(raw):
    return VaultAES256.encrypt(raw,vault_pass)
def decrypt(raw):
    return VaultAES256.decrypt(raw,vault_pass)

def output_encrypted_var(name, value,multiline):
    encrypted_value=vault.format_vaulttext_envelope(encrypt(value),'AES256')
    if not multiline:
        indent=' '* (singline_indent-len(name))
        output(name+": !vault " +indent+encrypted_value.replace("\n", "\\n"))
    else:
        output(name+": !vault |")
        indent=' '*10
        for line in encrypted_value.splitlines():
            output('%s%s' % (indent, line))


def encrypt_file(lines):
    cnt=0
    skipcnt=0
    for line in lines:
        #if args.debug:
        #    debug("Line {}: {}".format(cnt+1, line.rstrip()))
        if skipcnt>0:
            skipcnt-=1
            cnt+=1
            continue
        parts= re.split(":[ \t]*@savvy[ \t]*",line)
        if len(parts)==1:
            #debug("keeping: "+line)
            output(line.rstrip())
        elif parts[1].startswith('generate'):
            multiline=True #args.force_multine or len(options)>0
            value=randomstring()
            verbose("generating: "+parts[0])
            output_encrypted_var(parts[0], value, multiline)
        else:
            key=parts[0]
            remainder=re.sub("^[^:]*:[ \t]*@savvy[ \t]*","",line,1)
            value=re.sub("^[^:]*:[ \t]","",remainder,1).strip()
            #debug( "****"+remainder+"..."+value)
            if value.startswith('"') and value.endswith('"'):
                value=value[1:-1]
                # TODO: embedded quotes might be escaped
            (origkey,origvalue,origmultiline,count)=decrypt_line(lines,cnt+1)
            multiline=True #args.force_multine or len(options)>0
            debug("Found key %s with next key %s" % (key, origkey))
            if key!=origkey:
                verbose("new key: "+key)
                output_encrypted_var(key, value, multiline)
            elif value!=origvalue:
                verbose("changed key: "+key)
                output_encrypted_var(key, value, multiline)
                skipcnt=count
            elif multiline!=origmultiline:
                verbose("changed format: "+key)
                output_encrypted_var(key, value, multiline)
                skipcnt=count
            else:
                verbose("unmodified key: "+key)

        cnt+=1

def decrypt_file(lines):
    cnt=0
    for line in lines:
        #if args.debug:
        #    debug("Line {}: {}".format(cnt+1, line.rstrip()))
        parts= re.split(":[ \t]*",line)
        if len(parts)>1:
            (key, value, multiline, count) = decrypt_line(lines, cnt)
            if key:
                if multiline:
                    verbose("multiline: "+key)
                    str = key+": @savvy multiline: "+value
                else:
                    verbose("singleline: "+key)
                    str = key+": @savvy: "+value
                if mergelines:
                    mergelines.append(str)
                else:
                    output(str)

        output(line.rstrip())
        cnt+=1

def show_file(lines):
    cnt=0
    for line in lines:
        parts= re.split(":[ \t]*",line)
        if len(parts)>1:
            (key, value, multiline, skipcount) = decrypt_line(lines, cnt)
            if key:
                output(key+": "+value)
        cnt+=1


def decrypt_line(lines, index):
    parts= re.split(":[ \t]*",lines[index])
    if len(parts)==1:
        return (None,None,False,0)
    str=""
    multiline=False
    skipcount=0
    if re.search('!vault[ \t]*\|',parts[1]):
        i=index+2
        skipcount=2
        while i<len(lines) and re.search('^[ \t]*[0-9a]*[ \t]*$',lines[i]):
            str+=lines[i].strip()
            i+=1
            skipcount+=1
        multiline=True
    elif parts[1].startswith('!vault'):
        match=re.search('!vault[ \t]*\$ANSIBLE_VAULT;1.1;AES256', parts[1])
        if match:
            str=parts[1][match.end():].replace('\\n','').strip()
            skipcount=1
    if len(str)>0:
        return (parts[0].strip(), decrypt(str).strip(), multiline, skipcount)
    return (None,None,False,0)

def command(name):
    if len(name)<len(args.command):
        return False
    return name.startswith(args.command)

if command('encrypt'):
    lines=input_open()
    output_open(args.filename)
    encrypt_file(lines)
    output_close()
elif command('decrypt'):
    lines=input_open()
    output_open(args.filename)
    open_mergefile(None)
    decrypt_file(lines)
    close_mergefile()
    if not mergefile:
        output_close()
elif command('view'):
    lines=input_open()
    output_open("-")
    show_file(lines)
elif command('merge'):
    lines=input_open()
    output_open(args.filename)
    encrypt_file(lines)
    output_close()
elif command('split'):
    lines=input_open()
    open_mergefile('savvy.mergefile')
    output_open(args.filename)
    decrypt_file(lines)
    close_mergefile()
else:
    raise SystemExit("Unknown command '%s', must be any of %s\n" % (args.command, allcommands))
