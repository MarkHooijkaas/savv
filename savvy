#!/usr/bin/python

import sys
import re
import random
import string
import argparse
import os
import ansible.parsing.vault as vault
from ansible.parsing.vault import VaultAES256, VaultSecret
from getpass import getpass
from argparse import RawTextHelpFormatter

epilogtext='''
commands:
  - savvy decrypt: decrypt all !vault variables in a file with special @savvy marker
  - savvy split :  decrypt all !vault variables in a separate mergefile
  - savvy encrypt: encrypt all @savvy annotated variables in a file
  - savvy merge:   encrypt all variables from a mergefile into the main file (not implemented yet)
  - savvy view:    show all encrypted variables in a file
  - savvy edit:    decrypt, edit, and re-encrypt (not implemented yet)

All commands can be abbreviated with the first letter or letters, for example to decrypt:
  - savvy d
  - savvy de
  - savvy dec
  - savvy decr

If two commands start with the same letter(s) the first command will be used
  - savvy e     will encrypt
  - savvy ed    will edit
'''

allcommands="decrypt, encrypt, view, split, merge"
parser = argparse.ArgumentParser(description='Single Ansible Vault Var encrYpter/decrYpter', epilog=epilogtext,  formatter_class=RawTextHelpFormatter)
#parser.add_argument('-m', '--multi', action='store_true', help='use multiline format')
parser.add_argument('-q', '--quiet', action='store_true', help='show no informational output')
parser.add_argument('-d', '--debug', action='store_true', help='print debug info')
parser.add_argument('-c', '--check', action='store_true', help='check mode (dry-run)')
parser.add_argument('-a', '--ask-password',  action='store_true',help='ask for a password (even if VAULT_PASS is set)')
parser.add_argument('-o', '--output', help='output file')
parser.add_argument('-j', '--mergefile', help='merge file with passwords to be split from or merged into main file')
parser.add_argument('command', help=allcommands)
parser.add_argument('filename', nargs='?', default='group_vars/all/vars.yml', help='file to work on')
args = parser.parse_args()
singline_indent=40
multiline_format=True

if 'VAULT_PASS' in os.environ and not args.ask_password:
    vault_pass=VaultSecret(os.environ['VAULT_PASS'])
else:
    vault_pass = VaultSecret(getpass("Vault Password:"))

def input_open():
    verbose('Reading input file: '+args.filename)
    with open(args.filename) as inp:
        inputlines = inp.read().splitlines()
    return inputlines

outputfile=None
outputlines=[]
def output_open(defaultfile):
    global outputfile
    if args.output:
        file=args.output
    else:
        file=defaultfile
    if file==None or file=="-":
        outputfile=None
    else:
        outputfile=file
def output_close():
    if outputfile==None or outputfile=="-" or args.check:
        return
    else:
        verbose("Writing to file: "+outputfile)
        f = open(outputfile, "w")
        for l in outputlines:
            f.write(l)
def output(str, newline=True):
    if outputfile==None:
        print(str)
    else:
        if newline:
            outputlines.append(str+"\n")
        else:
            outputlines.append(str)

mergefile=None
mergelines=None
mergedict=None
def open_mergefile(defaultfile):
    global mergelines
    global mergefile
    global mergedict
    if (args.mergefile):
        mergefile=args.mergefile
    else:
        mergefile=defaultfile
    if mergefile:
        mergelines=['---', '']
        mergedict=dict()
def read_mergefile(all=True):
    # TODO: pass lines, to avoid reading file twice
    if mergefile:
        verbose("Reading merge file: "+mergefile)
        with open(mergefile) as inp:
            lines = inp.readlines()
        for l in lines:
            (savvy, key, value)=parse_line(l)
            if savvy or (key and all):
                debug('reading: '+savvy.ljust(17)+':'+key)
                mergedict[key] = (savvy, value)
def write_mergefile():
    if mergelines:
        verbose("Writing to mergefile: "+mergefile)
        f = open(mergefile, "w")
        for l in mergelines:
            f.write(l+"\n")
def parse_line(line):
    savvy=''
    if line.startswith('@savvy'):
        savvy=re.sub(':.*','',line).strip()
        line=re.sub('^[@a-zA-Z_0-9\t ]*:','',line).strip()
    if not re.search("^[a-zA-Z_0-9\t ]*:",line):
        return (None, None, None)
    key=re.sub(':.*','',line).strip()
    value=re.sub('[^:]*:','',line).strip()
    if value.startswith('"') and value.endswith('"'):
        value=value[1:-1]
        # TODO: embedded quotes might be escaped
    return (savvy, key, value)


def verbose(str):
    if args.quiet:
        return
    print(str)
def debug(str):
    if args.quiet:
        return
    if args.debug:
        print(str)



def randomstring(length=16):
    letters = string.ascii_lowercase + string.ascii_uppercase + string.digits
    return ''.merge(random.SystemRandom().choice(letters) for i in range(length))

def encrypt(raw):
    return VaultAES256.encrypt(raw,vault_pass)
def decrypt(raw):
    return VaultAES256.decrypt(raw,vault_pass)

def output_encrypted_var(name, value,multiline):
    encrypted_value=vault.format_vaulttext_envelope(encrypt(value),'AES256')
    if not multiline:
        indent=' '* (singline_indent-len(name))
        output(name+": !vault " +indent+encrypted_value.replace("\n", "\\n"))
    else:
        output(name+": !vault |")
        indent=' '*10
        for line in encrypted_value.splitlines():
            output('%s%s' % (indent, line))


def encrypt_file(lines):
    cnt=0
    skipcnt=0
    for line in lines:
        #if args.debug:
        #    debug("Line {}: {}".format(cnt+1, line.rstrip()))
        cnt+=1
        if skipcnt>0:
            skipcnt-=1
            continue
        (savvy, key, value)=parse_line(line)
        if savvy:
            debug("removing @savvy line: "+line)
            continue
        elif not (key or value):
            debug("keeping non-var line: "+line)
            output(line.rstrip())
            continue
        elif not re.search("\!vault",value):
            debug("keeping non vault line: "+line)
            output(line.rstrip())
            continue
        (origkey,origvalue,origmultiline,count)=decrypt_line(lines,cnt-1)
        if savvy and re.search("generate",savvy):
            newvalue=randomstring()
            verbose("generating: "+key)
            output_encrypted_var(key, newvalue, multiline_format)
        elif key in mergedict:
            (newsavvy, newvalue)=mergedict[key]
            mergedict.pop(key)
            if origvalue!=newvalue:
                verbose("  modified key: "+key)
                output_encrypted_var(key, newvalue, multiline_format)
                debug("skipping %d lines" % count)
                skipcnt=count
            elif multiline_format!=origmultiline:
                verbose("  reformat key: "+key)
                output_encrypted_var(key, newvalue, multiline_format)
                debug("skipping %d lines" % count)
                skipcnt=count
            else:
                verbose("unmodified key: "+key)
                output(line.rstrip())
        else:
            debug("unmergable key: "+key)
            output(line.rstrip())
    for key in mergedict:
        verbose('unmerged key: '+key)

def decrypt_file(lines):
    cnt=0
    for line in lines:
        #if args.debug:
        #    debug("Line {}: {}".format(cnt+1, line.rstrip()))
        parts= re.split(":[ \t]*",line)
        if len(parts)>1:
            (key, value, multiline, count) = decrypt_line(lines, cnt)
            if key:
                if multiline:
                    verbose("multiline: "+key)
                    str = "@savvy: "+key+": "+value
                elif multiline:
                    verbose("multiline: "+key)
                    str = "@savvy: "+key+": "+value
                else:
                    verbose("singleline: "+key)
                    str = "@savvy singleline: "+key+": "+value
                if mergelines:
                    mergelines.append(str)
                else:
                    output(str)

        output(line.rstrip())
        cnt+=1

def show_file(lines):
    cnt=0
    for line in lines:
        parts= re.split(":[ \t]*",line)
        if len(parts)>1:
            (key, value, multiline, skipcount) = decrypt_line(lines, cnt)
            if key:
                output(key+": "+value)
        cnt+=1


def decrypt_line(lines, index):
    parts= re.split(":[ \t]*",lines[index])
    if len(parts)==1 or parts[0].startswith('@savvy'):
        return (None,None,False,0)
    str=""
    multiline=False
    skipcount=0
    if re.search('!vault[ \t]*\|',parts[1]):
        i=index+2
        skipcount=1
        while i<len(lines) and re.search('^[ \t]*[0-9a]*[ \t]*$',lines[i]):
            str+=lines[i].strip()
            i+=1
            skipcount+=1
        multiline=True
    elif parts[1].startswith('!vault'):
        match=re.search('!vault[ \t]*\$ANSIBLE_VAULT;1.1;AES256', parts[1])
        if match:
            str=parts[1][match.end():].replace('\\n','').strip()
            skipcount=1
    if len(str)>0:
        return (parts[0].strip(), decrypt(str).strip(), multiline, skipcount)
    return (None,None,False,0)

def command(name):
    if len(name)<len(args.command):
        return False
    return name.startswith(args.command)

if command('encrypt'):
    open_mergefile('group_vars/all/vars.yml')
    read_mergefile(all=False)
    lines=input_open()
    output_open(args.filename)
    encrypt_file(lines)
    output_close()
elif command('decrypt'):
    open_mergefile(None)
    lines=input_open()
    output_open(args.filename)
    decrypt_file(lines)
    write_mergefile()
    if not mergefile:
        output_close()
elif command('view'):
    lines=input_open()
    output_open("-")
    show_file(lines)
elif command('merge'):
    open_mergefile('savvy.mergefile')
    read_mergefile(all=True)
    lines=input_open()
    output_open(args.filename)
    encrypt_file(lines)
    output_close()
elif command('split'):
    lines=input_open()
    open_mergefile('savvy.mergefile')
    output_open(args.filename)
    decrypt_file(lines)
    write_mergefile()
else:
    raise SystemExit("Unknown command '%s', must be any of %s\n" % (args.command, allcommands))
